/**
 * åŒDeepSeek APIå®¢æˆ·ç«¯
 * æ”¯æŒäº‘ç«¯APIå’Œæœ¬åœ°APIä¹‹é—´çš„æ™ºèƒ½åˆ‡æ¢
 */

import { DeepSeekConfigManager, getDeepSeekConfig, type DeepSeekProvider } from './deepseek-config';

interface ChatMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

interface ChatCompletionRequest {
  model?: string;
  messages: ChatMessage[];
  temperature?: number;
  max_tokens?: number;
  stream?: boolean;
}

interface ChatCompletionResponse {
  choices: Array<{
    message: {
      content: string;
      role: string;
    };
    finish_reason: string;
  }>;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
  model?: string;
  provider?: DeepSeekProvider;
}

/**
 * æœ¬åœ°APIå“åº”æ ¼å¼ (Ollamaæ ¼å¼)
 */
interface LocalChatResponse {
  model: string;
  created_at: string;
  message: {
    role: string;
    content: string;
  };
  done: boolean;
}

/**
 * åŒDeepSeek APIå®¢æˆ·ç«¯ç±»
 */
export class DualDeepSeekClient {
  private configManager: DeepSeekConfigManager;

  constructor() {
    this.configManager = getDeepSeekConfig();
  }

  /**
   * åˆ›å»ºèŠå¤©å®Œæˆ - æ™ºèƒ½é€‰æ‹©API
   */
  async createChatCompletion(request: ChatCompletionRequest): Promise<ChatCompletionResponse> {
    // è‡ªåŠ¨é€‰æ‹©æœ€ä½³æä¾›å•†
    const provider = await this.configManager.selectBestProvider();
    
    try {
      if (provider === 'cloud') {
        return await this.createCloudChatCompletion(request);
      } else {
        return await this.createLocalChatCompletion(request);
      }
    } catch (error) {
      console.error(`${provider === 'cloud' ? 'äº‘ç«¯' : 'æœ¬åœ°'}APIè°ƒç”¨å¤±è´¥:`, error);
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯è¶…æ—¶é”™è¯¯
      const isTimeoutError = error instanceof Error && (
        error.name === 'AbortError' || 
        error.message.includes('aborted') ||
        error.message.includes('timeout')
      );
      
      // å¦‚æœæ˜¯æœ¬åœ°APIè¶…æ—¶ä¸”äº‘ç«¯APIä¸å¯ç”¨ï¼Œæä¾›å‹å¥½çš„é”™è¯¯ä¿¡æ¯
      if (provider === 'local' && isTimeoutError && !this.configManager.isCloudAPIAvailable()) {
        throw new Error(`æœ¬åœ°APIåˆ†æè¶…æ—¶ï¼ˆå¯èƒ½ç”±äºæ–‡æ¡£å¤æ‚åº¦è¾ƒé«˜ï¼‰ã€‚å»ºè®®ï¼š
1. ç­‰å¾…å½“å‰åˆ†æå®Œæˆï¼ˆæœ¬åœ°æ¨¡å‹æ­£åœ¨å¤„ç†ä¸­ï¼‰
2. å°è¯•åˆ†æè¾ƒçŸ­çš„æ–‡æ¡£ç‰‡æ®µ
3. é…ç½®äº‘ç«¯APIä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆ
4. æ£€æŸ¥æœ¬åœ°æ¨¡å‹æ€§èƒ½å’Œèµ„æºä½¿ç”¨æƒ…å†µ`);
      }
      
      // å°è¯•å¤‡ç”¨æ–¹æ¡ˆï¼ˆä»…å½“å¤‡ç”¨æ–¹æ¡ˆå¯ç”¨æ—¶ï¼‰
      const fallbackProvider = provider === 'cloud' ? 'local' : 'cloud';
      const canUseFallback = fallbackProvider === 'cloud' 
        ? this.configManager.isCloudAPIAvailable() 
        : await this.configManager.isLocalAPIAvailable();
      
      if (canUseFallback) {
        console.log(`ğŸ”„ å°è¯•åˆ‡æ¢åˆ°${fallbackProvider === 'cloud' ? 'äº‘ç«¯' : 'æœ¬åœ°'}API...`);
        
        try {
          if (fallbackProvider === 'cloud') {
            return await this.createCloudChatCompletion(request);
          } else {
            return await this.createLocalChatCompletion(request);
          }
        } catch (fallbackError) {
          console.error(`å¤‡ç”¨APIä¹Ÿå¤±è´¥:`, fallbackError);
          throw new Error(`æ‰€æœ‰DeepSeek APIéƒ½ä¸å¯ç”¨: ä¸»è¦é”™è¯¯: ${error instanceof Error ? error.message : error} | å¤‡ç”¨é”™è¯¯: ${fallbackError instanceof Error ? fallbackError.message : fallbackError}`);
        }
      } else {
        // æ²¡æœ‰å¯ç”¨çš„å¤‡ç”¨æ–¹æ¡ˆ
        if (isTimeoutError) {
          throw new Error(`${provider === 'cloud' ? 'äº‘ç«¯' : 'æœ¬åœ°'}APIåˆ†æè¶…æ—¶ã€‚è¿™é€šå¸¸æ˜¯ç”±äºæ–‡æ¡£å†…å®¹å¤æ‚å¯¼è‡´çš„ã€‚å»ºè®®ï¼š
1. å°è¯•åˆ†æè¾ƒçŸ­çš„æ–‡æ¡£ç‰‡æ®µ
2. ç­‰å¾…ç‰‡åˆ»åé‡è¯•
3. ${provider === 'local' ? 'é…ç½®äº‘ç«¯APIå¯†é’¥ä½œä¸ºå¤‡ç”¨' : 'é…ç½®æœ¬åœ°APIä½œä¸ºå¤‡ç”¨'}`);
        } else {
          throw error;
        }
      }
    }
  }

  /**
   * äº‘ç«¯APIè°ƒç”¨
   */
  private async createCloudChatCompletion(request: ChatCompletionRequest): Promise<ChatCompletionResponse> {
    // ç›´æ¥è·å–äº‘ç«¯é…ç½®ï¼Œä¸ä¾èµ–å½“å‰æ´»åŠ¨æä¾›å•†
    const config = this.configManager.getConfig();
    
    if (!config.cloudConfig.apiKey) {
      throw new Error('äº‘ç«¯APIå¯†é’¥æœªé…ç½®');
    }

    const url = `${config.cloudConfig.baseURL}/chat/completions`;
    
    const requestBody = {
      model: request.model || config.cloudConfig.model,
      messages: request.messages,
      temperature: request.temperature ?? 0.1,
      max_tokens: request.max_tokens ?? 4000,
      stream: request.stream ?? false
    };

    console.log('ğŸŒ è°ƒç”¨äº‘ç«¯DeepSeek API...');
    const response = await this.makeRequest(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${config.cloudConfig.apiKey}`,
      },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`äº‘ç«¯APIé”™è¯¯: ${response.status} - ${errorText}`);
    }

    const result = await response.json();
    result.provider = 'cloud';
    console.log('âœ… äº‘ç«¯APIè°ƒç”¨æˆåŠŸ');
    
    return result;
  }

  /**
   * æœ¬åœ°APIè°ƒç”¨ (ä½¿ç”¨OpenAIå…¼å®¹æ ¼å¼)
   */
  private async createLocalChatCompletion(request: ChatCompletionRequest): Promise<ChatCompletionResponse> {
    // ç¡®ä¿æœ¬åœ°APIå¯ç”¨å¹¶è·å–æ­£ç¡®çš„æ¨¡å‹åç§°
    const isAvailable = await this.configManager.isLocalAPIAvailable();
    if (!isAvailable) {
      throw new Error('æœ¬åœ°APIä¸å¯ç”¨æˆ–æ²¡æœ‰å¯ç”¨çš„æ¨¡å‹');
    }
    
    // è·å–æ›´æ–°åçš„é…ç½®ï¼ˆå¯èƒ½åŒ…å«è‡ªåŠ¨æ£€æµ‹çš„æ¨¡å‹åç§°ï¼‰
    const updatedConfig = this.configManager.getActiveConfig();
    
    // ä½¿ç”¨æ–°çš„OpenAIå…¼å®¹æ¥å£
    const url = `${updatedConfig.baseURL}/v1/chat/completions`;
    
    const requestBody = {
      model: request.model || updatedConfig.model, // ä½¿ç”¨æ›´æ–°åçš„æ¨¡å‹åç§°
      messages: request.messages,
      temperature: request.temperature ?? 0.3, // æ ¹æ®æ–‡æ¡£å»ºè®®ï¼Œå­¦æœ¯ç¼–è¾‘ä½¿ç”¨è¾ƒä½çš„éšæœºæ€§
      max_tokens: request.max_tokens ?? 4000,
      stream: request.stream ?? false
    };

    console.log(`ğŸ  è°ƒç”¨æœ¬åœ°APIèŠå¤©æ¥å£ (æ¨¡å‹: ${requestBody.model})...`);
    console.log(`ğŸ“ APIåœ°å€: ${url}`);
    console.log(`ğŸ“ æ¶ˆæ¯æ•°é‡: ${requestBody.messages.length}`);
    console.log(`â³ æœ¬åœ°APIè°ƒç”¨å°†ç­‰å¾…ç›´åˆ°å®Œæˆï¼Œä¸è®¾ç½®è¶…æ—¶é™åˆ¶...`);
    
    // æœ¬åœ°APIè°ƒç”¨ä¸è®¾ç½®è¶…æ—¶ï¼Œä¸€ç›´ç­‰å¾…ç›´åˆ°è¿”å›ç»“æœ
    const response = await this.makeLocalRequest(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ollama'
      },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      const errorText = await response.text();
      
      // å¦‚æœæ˜¯404é”™è¯¯ï¼Œå¯èƒ½æ˜¯æ¨¡å‹åç§°é—®é¢˜
      if (response.status === 404 || errorText.includes('model') || errorText.includes('not found')) {
        const availableModels = await this.configManager.getAvailableLocalModels();
        
        // å¦‚æœæœ‰å¯ç”¨æ¨¡å‹ï¼Œå°è¯•ä½¿ç”¨ç¬¬ä¸€ä¸ªæ¨¡å‹é‡æ–°è°ƒç”¨
        if (availableModels.length > 0) {
          const fallbackModel = availableModels[0];
          console.log(`ğŸ”„ å°è¯•ä½¿ç”¨å¤‡ç”¨æ¨¡å‹: ${fallbackModel}`);
          
          // æ›´æ–°é…ç½®ä¸­çš„æ¨¡å‹åç§°
          this.configManager.updateConfig({
            localConfig: {
              ...this.configManager.getConfig().localConfig,
              model: fallbackModel
            }
          });
          
          // é‡æ–°æ„å»ºè¯·æ±‚
          const fallbackRequestBody = {
            ...requestBody,
            model: fallbackModel
          };
          
          const fallbackResponse = await this.makeLocalRequest(url, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': 'Bearer ollama'
            },
            body: JSON.stringify(fallbackRequestBody)
          });
          
          if (fallbackResponse.ok) {
            const result = await fallbackResponse.json();
            
            // OpenAIå…¼å®¹æ ¼å¼ï¼Œç›´æ¥è¿”å›ï¼Œåªéœ€æ·»åŠ provideræ ‡è¯†
            result.provider = 'local';
            console.log(`âœ… æœ¬åœ°APIè°ƒç”¨æˆåŠŸ (ä½¿ç”¨æ¨¡å‹: ${fallbackModel})`);
            console.log(`ğŸ“Š å“åº”é•¿åº¦: ${result.choices[0]?.message?.content?.length || 0} å­—ç¬¦`);
            return result;
          }
        }
        
        throw new Error(
          `æœ¬åœ°APIé”™è¯¯: æ¨¡å‹ "${requestBody.model}" ä¸å­˜åœ¨ã€‚` +
          `å¯ç”¨æ¨¡å‹: ${availableModels.join(', ') || 'æ— '}`
        );
      }
      
      throw new Error(`æœ¬åœ°APIé”™è¯¯: ${response.status} - ${errorText}`);
    }

    const result = await response.json();
    
    // OpenAIå…¼å®¹æ ¼å¼ï¼Œç›´æ¥è¿”å›ï¼Œåªéœ€æ·»åŠ provideræ ‡è¯†
    result.provider = 'local';
    console.log('âœ… æœ¬åœ°APIè°ƒç”¨æˆåŠŸ');
    console.log(`ğŸ“Š å“åº”é•¿åº¦: ${result.choices[0]?.message?.content?.length || 0} å­—ç¬¦`);
    
    return result;
  }

  /**
   * æ‰‹åŠ¨åˆ‡æ¢APIæä¾›å•†
   */
  async switchProvider(provider: DeepSeekProvider): Promise<boolean> {
    try {
      if (provider === 'cloud') {
        if (!this.configManager.isCloudAPIAvailable()) {
          throw new Error('äº‘ç«¯APIæœªé…ç½®æˆ–ä¸å¯ç”¨');
        }
      } else {
        if (!await this.configManager.isLocalAPIAvailable()) {
          throw new Error('æœ¬åœ°APIä¸å¯ç”¨');
        }
      }

      this.configManager.setProvider(provider);
      console.log(`âœ… æˆåŠŸåˆ‡æ¢åˆ°${provider === 'cloud' ? 'äº‘ç«¯' : 'æœ¬åœ°'}API`);
      return true;
    } catch (error) {
      console.error(`åˆ‡æ¢åˆ°${provider === 'cloud' ? 'äº‘ç«¯' : 'æœ¬åœ°'}APIå¤±è´¥:`, error);
      return false;
    }
  }

  /**
   * è·å–å½“å‰æä¾›å•†
   */
  getCurrentProvider(): DeepSeekProvider {
    return this.configManager.getProvider();
  }

  /**
   * æµ‹è¯•æŒ‡å®šæä¾›å•†çš„è¿æ¥
   */
  async testProviderConnection(provider: DeepSeekProvider): Promise<void> {
    if (provider === 'cloud') {
      // ç›´æ¥è·å–äº‘ç«¯é…ç½®è¿›è¡Œæµ‹è¯•ï¼Œä¸ä¾èµ–å½“å‰æ´»åŠ¨æä¾›å•†
      const config = this.configManager.getConfig();
      if (!config.cloudConfig.apiKey) {
        throw new Error('äº‘ç«¯APIå¯†é’¥æœªé…ç½®');
      }

      const url = `${config.cloudConfig.baseURL}/chat/completions`;
      const requestBody = {
        model: config.cloudConfig.model,
        messages: [{ role: 'user', content: 'æµ‹è¯•è¿æ¥' }],
        temperature: 0.1,
        max_tokens: 10,
        stream: false
      };

      const response = await this.makeRequest(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ollama'
        },
        body: JSON.stringify(requestBody)
      }, 'health-check');

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`äº‘ç«¯APIé”™è¯¯: ${response.status} - ${errorText}`);
      }
    } else {
      // æµ‹è¯•æœ¬åœ°APIï¼Œç›´æ¥ä½¿ç”¨æœ¬åœ°é…ç½®
      const config = this.configManager.getConfig();
      
      // å…ˆæ£€æŸ¥æœ¬åœ°APIæ˜¯å¦å¯ç”¨
      const isAvailable = await this.configManager.isLocalAPIAvailable();
      if (!isAvailable) {
        throw new Error('æœ¬åœ°APIä¸å¯ç”¨æˆ–æ²¡æœ‰å¯ç”¨çš„æ¨¡å‹');
      }
      
      // ä¿®å¤ï¼šç¡®ä¿URLæ ¼å¼æ­£ç¡®ï¼Œé¿å…é‡å¤çš„/v1
      const baseURL = config.localConfig.baseURL;
      const url = baseURL.endsWith('/v1') 
        ? `${baseURL}/chat/completions`
        : `${baseURL}/v1/chat/completions`;
      const requestBody = {
        model: config.localConfig.model,
        messages: [{ role: 'user', content: 'æµ‹è¯•è¿æ¥' }],
        temperature: 0.1,
        max_tokens: 10,
        stream: false
      };

      const response = await this.makeRequest(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ollama'
        },
        body: JSON.stringify(requestBody)
      }, 'health-check');

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`æœ¬åœ°APIé”™è¯¯: ${response.status} - ${errorText}`);
      }
    }
  }

  /**
   * å¥åº·æ£€æŸ¥ - ä½¿ç”¨çŸ­è¶…æ—¶æ—¶é—´çš„ç®€åŒ–è¯·æ±‚
   */
  private async quickHealthCheck(provider: DeepSeekProvider): Promise<void> {
    if (provider === 'cloud') {
      // ç›´æ¥ä½¿ç”¨äº‘ç«¯é…ç½®ï¼Œä¸ä¾èµ–å½“å‰æ´»åŠ¨æä¾›å•†
      const config = this.configManager.getConfig();
      if (!config.cloudConfig.apiKey) {
        throw new Error('äº‘ç«¯APIå¯†é’¥æœªé…ç½®');
      }

      const url = `${config.cloudConfig.baseURL}/chat/completions`;
      const requestBody = {
        model: config.cloudConfig.model,
        messages: [{ role: 'user', content: 'æµ‹è¯•' }],
        temperature: 0.1,
        max_tokens: 5,
        stream: false
      };

      const response = await this.makeRequest(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ollama'
        },
        body: JSON.stringify(requestBody)
      }, 'health-check'); // ä½¿ç”¨å¥åº·æ£€æŸ¥çš„çŸ­è¶…æ—¶æ—¶é—´

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`äº‘ç«¯APIé”™è¯¯: ${response.status} - ${errorText}`);
      }
    } else {
      // æœ¬åœ°APIå¥åº·æ£€æŸ¥ï¼Œç›´æ¥ä½¿ç”¨æœ¬åœ°é…ç½®
      const config = this.configManager.getConfig();
      
      const isAvailable = await this.configManager.isLocalAPIAvailable();
      if (!isAvailable) {
        throw new Error('æœ¬åœ°APIä¸å¯ç”¨æˆ–æ²¡æœ‰å¯ç”¨çš„æ¨¡å‹');
      }
      
      const url = `${config.localConfig.baseURL}/v1/chat/completions`;
      const requestBody = {
        model: config.localConfig.model,
        messages: [{ role: 'user', content: 'æµ‹è¯•' }],
        temperature: 0.1,
        max_tokens: 10,
        stream: false
      };

      const response = await this.makeRequest(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ollama'
        },
        body: JSON.stringify(requestBody)
      }, 'health-check'); // ä½¿ç”¨å¥åº·æ£€æŸ¥çš„çŸ­è¶…æ—¶æ—¶é—´

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`æœ¬åœ°APIé”™è¯¯: ${response.status} - ${errorText}`);
      }
    }
  }

  /**
   * å¥åº·æ£€æŸ¥
   */
  async healthCheck(): Promise<{
    cloud: { available: boolean; error?: string };
    local: { available: boolean; error?: string };
    current: DeepSeekProvider;
  }> {
    const result = {
      cloud: { available: false, error: undefined as string | undefined },
      local: { available: false, error: undefined as string | undefined },
      current: this.configManager.getProvider()
    };

    // æ£€æŸ¥äº‘ç«¯API
    try {
      if (this.configManager.isCloudAPIAvailable()) {
        await this.quickHealthCheck('cloud');
        result.cloud.available = true;
      } else {
        result.cloud.error = 'APIå¯†é’¥æœªé…ç½®';
      }
    } catch (error) {
      result.cloud.error = error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯';
    }

    // æ£€æŸ¥æœ¬åœ°API
    try {
      await this.quickHealthCheck('local');
      result.local.available = true;
    } catch (error) {
      result.local.error = error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯';
    }

    return result;
  }

  /**
   * è·å–çŠ¶æ€æŠ¥å‘Š
   */
  async getStatusReport(): Promise<{
    currentProvider: DeepSeekProvider;
    cloudStatus: { available: boolean; configured: boolean };
    localStatus: { available: boolean; configured: boolean };
    recommendations: string[];
  }> {
    return await this.configManager.getStatusReport();
  }

  /**
   * ç”Ÿæˆæ–‡æœ¬åµŒå…¥å‘é‡ - ä½¿ç”¨æœ¬åœ°ç®—æ³•
   * æ³¨æ„ï¼šç›®å‰ä¸¤ç§APIéƒ½æ²¡æœ‰ä¸“é—¨çš„embeddingæœåŠ¡ï¼Œç»§ç»­ä½¿ç”¨æœ¬åœ°ç®—æ³•
   */
  async createEmbedding(input: string | string[]): Promise<number[][]> {
    const texts = Array.isArray(input) ? input : [input];
    const embeddings: number[][] = [];

    for (const text of texts) {
      const embedding = this.generateAdvancedEmbedding(text);
      embeddings.push(embedding);
    }

    return embeddings;
  }

  /**
   * æ”¹è¿›çš„æœ¬åœ°åµŒå…¥å‘é‡ç”Ÿæˆç®—æ³•
   * åŸºäºè¯­ä¹‰ç‰¹å¾å’Œç»Ÿè®¡ç‰¹å¾çš„æ··åˆæ–¹æ³•
   */
  private generateAdvancedEmbedding(text: string): number[] {
    const dimension = 1024;
    const embedding = new Array(dimension).fill(0);
    
    // 1. åŸºç¡€æ–‡æœ¬ç‰¹å¾
    const textFeatures = this.extractTextFeatures(text);
    
    // 2. è¯­ä¹‰ç‰¹å¾æ˜ å°„
    const semanticFeatures = this.extractSemanticFeatures(text);
    
    // 3. é¢†åŸŸç‰¹å¾
    const domainFeatures = this.extractDomainFeatures(text);
    
    // 4. ç»Ÿè®¡ç‰¹å¾
    const statisticalFeatures = this.extractStatisticalFeatures(text);
    
    // 5. ç»„åˆç‰¹å¾åˆ°å‘é‡ç©ºé—´
    for (let i = 0; i < dimension; i++) {
      const featureIndex = i % 4;
      let value = 0;
      
      switch (featureIndex) {
        case 0:
          value = textFeatures[i % textFeatures.length];
          break;
        case 1:
          value = semanticFeatures[i % semanticFeatures.length];
          break;
        case 2:
          value = domainFeatures[i % domainFeatures.length];
          break;
        case 3:
          value = statisticalFeatures[i % statisticalFeatures.length];
          break;
      }
      
      const positionWeight = Math.sin(i / dimension * Math.PI);
      const noise = (Math.random() - 0.5) * 0.1;
      
      embedding[i] = value * positionWeight + noise;
    }
    
    return this.normalizeVector(embedding);
  }

  private extractTextFeatures(text: string): number[] {
    const features: number[] = [];
    const normalizedText = text.toLowerCase();
    
    const charFreq: Record<string, number> = {};
    for (const char of normalizedText) {
      charFreq[char] = (charFreq[char] || 0) + 1;
    }
    
    for (let i = 0; i < 256; i++) {
      const char = String.fromCharCode(i);
      features.push((charFreq[char] || 0) / text.length);
    }
    
    return features;
  }

  private extractSemanticFeatures(text: string): number[] {
    const features: number[] = [];
    
    const keywordWeights: Record<string, number> = {
      'ç ”ç©¶': 0.9, 'åˆ†æ': 0.8, 'å®éªŒ': 0.85, 'ç†è®º': 0.8, 'æ–¹æ³•': 0.7,
      'ç»“æœ': 0.75, 'ç»“è®º': 0.8, 'æ•°æ®': 0.7, 'æ¨¡å‹': 0.75, 'ç®—æ³•': 0.8,
      'é‡å­': 0.95, 'åˆ†å­': 0.9, 'è›‹ç™½è´¨': 0.9, 'åŸºå› ': 0.9, 'ç»†èƒ': 0.85,
      'ç‰©ç†': 0.8, 'åŒ–å­¦': 0.8, 'ç”Ÿç‰©': 0.8, 'åŒ»å­¦': 0.8, 'å·¥ç¨‹': 0.75,
      'å¢å¼º': 0.6, 'å‡å°‘': 0.6, 'æé«˜': 0.65, 'æ”¹å–„': 0.65, 'ä¼˜åŒ–': 0.7,
      'æ§åˆ¶': 0.65, 'è°ƒèŠ‚': 0.6, 'å½±å“': 0.6, 'ä¿ƒè¿›': 0.6, 'æŠ‘åˆ¶': 0.6
    };
    
    for (let i = 0; i < 256; i++) {
      let semanticScore = 0;
      for (const [keyword, weight] of Object.entries(keywordWeights)) {
        if (text.includes(keyword)) {
          semanticScore += weight * (text.split(keyword).length - 1) / text.length;
        }
      }
      features.push(Math.tanh(semanticScore + Math.sin(i * 0.1)));
    }
    
    return features;
  }

  private extractDomainFeatures(text: string): number[] {
    const features: number[] = [];
    
    const domainPatterns = {
      academic: /å­¦æœ¯|ç ”ç©¶|è®ºæ–‡|æœŸåˆŠ|ä¼šè®®|å¼•ç”¨/g,
      medical: /åŒ»å­¦|ç–¾ç—…|æ²»ç–—|è¯ç‰©|ä¸´åºŠ|ç—…ç†/g,
      technical: /æŠ€æœ¯|å·¥ç¨‹|ç®—æ³•|ç³»ç»Ÿ|æ¶æ„|å¼€å‘/g,
      legal: /æ³•å¾‹|æ¡ä¾‹|è§„å®š|åˆåŒ|åè®®|æ³•è§„/g,
      business: /å•†ä¸š|å¸‚åœº|é”€å”®|ç®¡ç†|ç­–ç•¥|å®¢æˆ·/g,
      science: /ç§‘å­¦|å®éªŒ|æ•°æ®|å‡è®¾|éªŒè¯|è§‚å¯Ÿ/g
    };
    
    for (let i = 0; i < 256; i++) {
      let domainScore = 0;
      for (const pattern of Object.values(domainPatterns)) {
        const matches = text.match(pattern);
        if (matches) {
          domainScore += matches.length / text.length;
        }
      }
      features.push(domainScore + Math.cos(i * 0.05));
    }
    
    return features;
  }

  private extractStatisticalFeatures(text: string): number[] {
    const features: number[] = [];
    
    const length = text.length;
    const words = text.split(/\s+/).length;
    const sentences = text.split(/[ã€‚ï¼ï¼Ÿ.!?]/).length;
    const avgWordLength = words > 0 ? length / words : 0;
    const avgSentenceLength = sentences > 0 ? words / sentences : 0;
    
    for (let i = 0; i < 256; i++) {
      let feature = 0;
      switch (i % 5) {
        case 0:
          feature = length / 1000;
          break;
        case 1:
          feature = words / 100;
          break;
        case 2:
          feature = sentences / 10;
          break;
        case 3:
          feature = avgWordLength / 10;
          break;
        case 4:
          feature = avgSentenceLength / 20;
          break;
      }
      features.push(Math.tanh(feature + Math.random() * 0.1));
    }
    
    return features;
  }

  private normalizeVector(vector: number[]): number[] {
    const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
    return magnitude > 0 ? vector.map(val => val / magnitude) : vector;
  }

  /**
   * å‘èµ·æœ¬åœ°APIè¯·æ±‚ - ä¸è®¾ç½®è¶…æ—¶ï¼Œä¸€ç›´ç­‰å¾…ç›´åˆ°è¿”å›ç»“æœ
   */
  private async makeLocalRequest(url: string, options: RequestInit): Promise<Response> {
    console.log(`ğŸ”„ å‘èµ·æœ¬åœ°APIè¯·æ±‚ï¼Œæ— è¶…æ—¶é™åˆ¶...`);

    try {
      const response = await fetch(url, options);
      return response;
    } catch (error) {
      throw error;
    }
  }

  /**
   * å‘èµ·HTTPè¯·æ±‚
   */
  private async makeRequest(url: string, options: RequestInit, taskType: 'default' | 'document-analysis' | 'health-check' = 'default'): Promise<Response> {
    const timeout = this.configManager.getTimeoutForTask(taskType);
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    console.log(`ğŸ”„ å‘èµ·${taskType === 'document-analysis' ? 'æ–‡æ¡£åˆ†æ' : taskType === 'health-check' ? 'å¥åº·æ£€æŸ¥' : ''}è¯·æ±‚ (è¶…æ—¶: ${timeout/1000}ç§’)`);

    try {
      const response = await fetch(url, {
        ...options,
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      return response;
    } catch (error) {
      clearTimeout(timeoutId);
      throw error;
    }
  }
}

/**
 * åˆ›å»ºåŒDeepSeekå®¢æˆ·ç«¯å®ä¾‹
 */
export function createDualDeepSeekClient(): DualDeepSeekClient {
  return new DualDeepSeekClient();
}

/**
 * å…¨å±€å®¢æˆ·ç«¯å®ä¾‹
 */
let globalClient: DualDeepSeekClient | null = null;

/**
 * è·å–å…¨å±€å®¢æˆ·ç«¯å®ä¾‹
 * æ”¯æŒå¼ºåˆ¶åˆ·æ–°é…ç½®
 */
export function getDualDeepSeekClient(forceRefresh: boolean = false): DualDeepSeekClient {
  if (!globalClient || forceRefresh) {
    globalClient = new DualDeepSeekClient();
  }
  return globalClient;
}

/**
 * æ¸…é™¤å…¨å±€å®¢æˆ·ç«¯ç¼“å­˜
 * åœ¨é…ç½®æ›´æ–°åè°ƒç”¨ï¼Œç¡®ä¿ä½¿ç”¨æ–°é…ç½®
 */
export function clearDualDeepSeekClient(): void {
  globalClient = null;
} 